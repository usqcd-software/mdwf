\documentclass[twoside,openright]{report}
\usepackage{noweb}
\noweboptions{externalindex,longchunks,longxref}
\usepackage[boxed]{algorithm2e}
%\usepackage{epsfig}
\usepackage{color}
\definecolor{darkblue}{cmyk}{1,1,0,0.7}
\usepackage[dvipdfm,colorlinks=true,linkcolor=darkblue]{hyperref}
\newcommand{\note}[1]{$[\![$NB: #1$]\!]$}
\setlength{\parindent}{0pt}
\setlength{\topmargin}{-40pt}
\setlength{\oddsidemargin}{-16pt}
\setlength{\evensidemargin}{-16pt}
\setlength{\textwidth}{522pt}
\setlength{\textheight}{700pt}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\newcommand{\Cee}{\texttt{C}}

\title{M\"obius Domain Wall Fermions Implementation}
\author{Andrew Pochinsky}
\catcode`\$=11
\date{$Id$\\
XXX WORKING COPY}
\catcode`\$=3

\begin{document}
\maketitle
\thispagestyle{empty}\hbox{}
\vfill
\copyright 2007 Massachusetts Institute of Technology

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
\pagebreak

\tableofcontents
\pagebreak

\chapter{PHYSICS}
The Domain Wall Fermion Dirac operator is defined by
\begin{equation}
\left\langle\bar\psi|D_{DW}|\psi\right\rangle =
  \sum_{x,x'}\bar\psi(x)D_{DW}(x,x')\psi(x'),
\end{equation}
where
\begin{eqnarray}
D_{DW}(x,x')  &= &D_{+}^{(s)}(x,x')\delta_{s,s'}\nonumber\\
    & & + D_{-}^{(s)}(x,x')P_{+}\delta_{s,s'+1}
       -mD_{-}^{(s)}(x,x')P_{+}\delta_{s,0}\delta_{s',L_s-1} \nonumber\\
   & &  + D_{-}^{(s)}(x,x')P_{-}\delta_{s,s'-1} 
       -mD_{-}^{(s)}(x,x')P_{-}\delta_{s,L_s-1}\delta_{s',0} \label{D_DW},\\
P_{+}&=&\frac{1+\gamma_5}{2},\\
P_{-}&=&\frac{1-\gamma_5}{2},\\
D_{+}^{(s)}(x,x')&=&b_5(s)D_W(x,x')+1,\\
D_{-}^{(s)}(x,x')&=&c_5(s)D_W(x,x')-1,
\end{eqnarray}
and
\begin{equation}
D_W(x,x')=(4+M_5)\delta_{x,x'}
 -\frac{1}{2}\sum_{\mu=0}^{3}
    \left[(1-\gamma_\mu)U_\mu(x)\delta_{x,x'-\hat\mu}
         +(1+\gamma_\mu)U_\mu^{\dagger}(x-\hat\mu)\delta_{x,x'+\hat\mu}\right]
\end{equation}
is the standard Wilson action.

\section{Gamma Matrices}
We use the same $\gamma$-matrix basis as Chroma to simplify conversion between
two codes. The choice below could be changed with a few modifications to the
rest of the code, if $\gamma_5$ is kept diagonal, and one of other
$\gamma$-matrices has all nonzero entries equal to $+1$.

In the $\gamma$-basis defined below one has
\begin{equation}
\gamma_5 = \gamma_0 \gamma_1 \gamma_2 \gamma_3 = \sigma_3 \otimes 1 =
           \left(\begin{array}{cc}
             1 & 0 \\
             0 & -1
           \end{array}\right) =
           \left(\begin{array}{cccc}
             1 & 0 & 0 & 0\\
             0 & 1 & 0 & 0\\
             0 & 0 &-1 & 0\\
             0 & 0 & 0 &-1
           \end{array}\right)
\end{equation}
Fragments for $\gamma_\mu$ below are not the most fool-proof, but they should do
for now.

\pagebreak
\begin{equation}
\gamma_0 = -\sigma_2 \otimes \sigma_1  =
           \left(\begin{array}{cc}
                0&i\sigma_1\\
                -i\sigma_1&0
             \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&0&i\\
                                 0&0&i&0\\
                                 0&-i&0&0\\
                                 -i&0&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_0)$>>=
((project 0 plus) . ((plus-one 0 plus-i 3)
	             (plus-one 1 plus-i 2)))
@
<<Unproject $(1+\gamma_0)$>>=
((unproject 0 plus) . ((plus-one 0)
                       (plus-one 1)
		       (minus-i 1)
		       (minus-i 0)))
@
<<Project $(1-\gamma_0)$>>=
((project 0 minus) . ((plus-one 0 minus-i 3)
   	              (plus-one 1 minus-i 2)))
@
<<Unproject $(1-\gamma_0)$>>=
((unproject 0 minus) . ((plus-one 0)
	     	        (plus-one 1)
		        (plus-i 1)
		        (plus-i 0)))
@

\pagebreak
\begin{equation}
\gamma_1 = \sigma_2 \otimes \sigma_2  = 
           \left(\begin{array}{cc}
                  0 & -i\sigma_2\\
                  i\sigma_2 & 0
                 \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&0&-1\\
                                 0&0&1&0\\
                                 0&1&0&0\\
                                 -1&0&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_1)$>>=
((project 1 plus) . ((plus-one 0 minus-one 3)
	   	     (plus-one 1 plus-one 2)))
@
<<Unproject $(1+\gamma_1)$>>=
((unproject 1 plus) . ((plus-one 0)
	     	       (plus-one 1)
		       (plus-one 1)
		       (minus-one 0)))
@
<<Project $(1-\gamma_1)$>>=
((project 1 minus) . ((plus-one 0 plus-one 3)
	   	      (plus-one 1 minus-one 2)))
@
<<Unproject $(1-\gamma_1)$>>=
((unproject 1 minus) . ((plus-one 0)
	     	        (plus-one 1)
		        (minus-one 1)
		        (plus-one 0)))
@

\pagebreak
\begin{equation}
\gamma_2 = -\sigma_2 \otimes \sigma_3  = 
           \left(\begin{array}{cc}
                   0 & i\sigma_3\\
                 -i\sigma_3&0
                 \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&i&0\\
                                 0&0&0&-i\\
                                 -i&0&0&0\\
                                 0&i&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_2)$>>=
((project 2 plus) . ((plus-one 0 plus-i 2)
	   	     (plus-one 1 minus-i 3)))
@
<<Unproject $(1+\gamma_2)$>>=
((unproject 2 plus) . ((plus-one 0)
	     	       (plus-one 1)
		       (minus-i 0)
		       (plus-i 1)))
@
<<Project $(1-\gamma_2)$>>=
((project 2 minus) . ((plus-one 0 minus-i 2)
	   	      (plus-one 1 plus-i 3)))
@
<<Unproject $(1-\gamma_2)$>>=
((unproject 2 minus) . ((plus-one 0)
	     	        (plus-one 1)
		        (plus-i 0)
		        (minus-i 1)))
@

\pagebreak
\begin{equation}
\gamma_3 = \sigma_1 \otimes 1 =
           \left(\begin{array}{cc}
                  0 & 1\\
                  1 & 0
                 \end{array}\right) = 
           \left(\begin{array}{cccc}
                                 0&0&1&0\\
                                 0&0&0&1\\
                                 1&0&0&0\\
                                 0&1&0&0
                           \end{array}\right)\\
\end{equation}
<<Project $(1+\gamma_3)$>>=
((project 3 plus) . ((plus-one 0 plus-one 2)
	   	     (plus-one 1 plus-one 3)))
@
<<Unproject $(1+\gamma_3)$>>=
((unproject 3 plus) . ((plus-one 0)
	     	       (plus-one 1)
		       (plus-one 0)
		       (plus-one 1)))
@
This is our starting point in sums over directions
<<Start $\mu$ sum>>=
(define mdwf-start-sum-dimension 3)
(define mdwf-start-sum-direction 'plus)
@

<<Project $(1-\gamma_3)$>>=
((project 3 minus) . ((plus-one 0 minus-one 2)
	   	      (plus-one 1 minus-one 3)))
@
<<Unproject $(1-\gamma_3)$>>=
((unproject 3 minus) . ((plus-one 0)
	     	        (plus-one 1)
		        (minus-one 0)
		        (minus-one 1)))
@

Now let us collect the $\gamma$-matrix projections and reconstructions. We
put them all together into [[mdwf-basis]] as an a list of pairs with keys
of the form [[(<op> <dir> <sign>)]].
<<Scheme definitions>>=
(define mdwf-basis '(
  <<Project $(1+\gamma_0)$>>
  <<Project $(1+\gamma_1)$>>
  <<Project $(1+\gamma_2)$>>
  <<Project $(1+\gamma_3)$>>
  <<Project $(1-\gamma_0)$>>
  <<Project $(1-\gamma_1)$>>
  <<Project $(1-\gamma_2)$>>
  <<Project $(1-\gamma_3)$>>
  <<Unproject $(1+\gamma_0)$>>
  <<Unproject $(1+\gamma_1)$>>
  <<Unproject $(1+\gamma_2)$>>
  <<Unproject $(1+\gamma_3)$>>
  <<Unproject $(1-\gamma_0)$>>
  <<Unproject $(1-\gamma_1)$>>
  <<Unproject $(1-\gamma_2)$>>
  <<Unproject $(1-\gamma_3)$>>))
@

We also define a starting link in a sum over links:
<<Scheme definitions>>=
<<Start $\mu$ sum>>
@

Here is a module for PLT:
<<File [[../utils/basis.ss]]>>=
(module basis
        mzscheme
   (provide mdwf-basis
            mdwf-start-sum-dimension
            mdwf-start-sum-direction)
   <<Scheme definitions>>
)
@

\pagebreak\section{Preconditioning}
We use four dimensional preconditioner to improve convergence of the CG.
Following Kostas Orginos, let us color the lattice sites according to the
parity of $x_0+x_1+x_2+x_3$. Then we can rewrite $D_{DW}$ from Eq.~(\ref{D_DW})
as follows:
\begin{equation}\label{EO-form}
D_{DW}=\left(\begin{array}{cc}
A_{oo} & F_{oe}B_{ee}\\
F_{eo}B_{oo} & A_{ee}
\end{array}\right),
\end{equation}
where
\begin{eqnarray}
A_{oo}(x,x') & = &\left\{(c_5(s)(M_5+4)-1)\left[P_{+}\delta_{s,s'+1}
       - mP_{+}\delta_{s,0}\delta_{s',L_s-1}
              +P_{-}\delta_{s,s'-1}
       -mP_{-}\delta_{s,L_s-1}\delta_{s',0}\right]\right.\nonumber\\
      && \left.+(b_5(s)(M_5+4)+1)\delta_{s,s'}\right\}\delta_{x,x'},\\
B_{oo}(x,x') & = & \left\{c_5(s)\left[P_{+}\delta_{s,s'+1}
     - mP_{+}\delta_{s,0}\delta_{s',L_s-1}
                +P_{-}\delta_{s,s'-1}
       -mP_{-}\delta_{s,L_s-1}\delta_{s',0}\right]+
       b_5(s)\delta_{s,s'}\right\}\delta_{x,x'},\\
F_{oe}(x,x') &=&-\frac{\delta_{s,s'}}{2}
            \sum_{\mu=0}^{3}\left[(1-\gamma_\mu)U_\mu(x)\delta_{x,x'-\hat\mu}
         +(1+\gamma_\mu)U_\mu^{\dagger}(x-\hat\mu)\delta_{x,x'+\hat\mu}\right],
\end{eqnarray}
and similary for other parity components. (On the LHS $x$ and $x'$ are 5-d
indices, hereafter spinor and color indices are suppressed but presumed.)

Let us rewrite Eq.~(\ref{EO-form}) as follows:
\begin{equation}
D_{DW}=
\left(\begin{array}{cc}
I_{oo} & 0\\
F_{eo}B_{oo}A_{oo}^{-1} & A_{ee}B_{ee}^{-1}
\end{array}\right)
\left(\begin{array}{cc}
A_{oo} & F_{oe}\\
0 & I_{ee}-B_{ee}A_{ee}^{-1}F_{eo}B_{oo}A_{oo}^{-1}F_{oe}
\end{array}\right)
\left(\begin{array}{cc}
I_{oo} & 0\\
0 & B_{ee}
\end{array}\right).
\end{equation}

To solve the equation
\[
D_{DW}\psi=
\left(\begin{array}{cc}
A_{oo} & F_{oe}B_{ee}\\
F_{eo}B_{oo} & A_{ee}
\end{array}\right)
\left(\begin{array}{c}\psi_e\\\psi_o\end{array}\right) =
   \left(\begin{array}{c}\eta_e\\\eta_o\end{array}\right),
\]
one performs the following steps:
\begin{enumerate}
\item Use $M=I_{ee}-B_{ee}A_{ee}^{-1}F_{eo}B_{oo}A_{oo}^{-1}F_{oe}$ in the
following.
\item Use $M^\dagger=I_{ee}-\left(F_{oe}\right)^\dagger
\left(A_{oo}^{-1}\right)^\dagger
\left(B_{oo}\right)^\dagger
\left(F_{eo}\right)^\dagger
\left(A_{ee}^{-1}\right)^\dagger
\left(B_{ee}\right)^\dagger$ in the following.
\item Compute
\[
\chi_e =M^{\dagger} B_{ee}A_{ee}^{-1}\left(\eta_e
            - F_{eo}B_{oo}A_{oo}^{-1}\eta_o\right).
\]
\item Solve
\[
M^{\dagger}M\xi_e = \chi_e
\]
for $\xi_e$ using Alg.~\ref{real}.
\item Compute
\begin{eqnarray}
\psi_o &=& A_{oo}^{-1}\left(\eta_o-F_{oe}\xi_e\right),\\
\psi_e &=& B_{ee}^{-1}\xi_e.
\end{eqnarray}
\end{enumerate}

\pagebreak
\section{Inverting $A$ and $B$}
Note that $A$ and $B$ have the following form:
\begin{eqnarray}
A(x,x') &=& \left[A_{+}(s,s')P_{+}+A_{-}(s,s')P_{-}\right]\delta_{x,x'}\\
B(x,x') &=& \left[B_{+}(s,s')P_{+}+B_{-}(s,s')P_{-}\right]\delta_{x,x'}
\end{eqnarray}
where
\begin{eqnarray}
\label{A+}
A_{+}(s,s') & = &u_\alpha(s)\delta_{s,s'+1}
                  +v_\alpha(s)\delta_{s,0}\delta_{s',L_s-1}
                  +w_\alpha(s)\delta_{s,s'},\\
\label{A-}
A_{-}(s,s') & = &u_\alpha(s)\delta_{s,s'-1}
                  +v_\alpha(s)\delta_{s,L_s-1}\delta_{s',0}
                  +w_\alpha(s)\delta_{s,s'},\\
\label{B+}
B_{+}(s,s') & = &u_\beta(s)\delta_{s,s'+1}
                  +v_\beta(s)\delta_{s,0}\delta_{s',L_s-1}
                  +w_\beta(s)\delta_{s,s'},\\
\label{B-}
B_{-}(s,s') & = &u_\beta(s)\delta_{s,s'-1}
                  +v_\beta(s)\delta_{s,L_s-1}\delta_{s',0}
                  +w_\beta(s)\delta_{s,s'};
\end{eqnarray}
and
\begin{eqnarray}
u_\alpha(s) &=&c_5(s)(M_5+4)-1,\\
v_\alpha(s)  &=&-m u_\alpha(s),\\
w_\alpha(s) &=&b_5(s)(M_5+4)+1,\\
u_\beta(s) &=&c_5(s),\\
v_\beta(s)  &=&-m u_\beta(s),\\
w_\beta(s) &=&b_5(s).
\end{eqnarray}
This allows us to invert $A$ and $B$ as follows.

For $A_{+}$ one has (formulae for $B_{+}$ are obtained by replacing
$\alpha$ with $\beta$, see Eqs.~(\ref{A+}) and~(\ref{B+})):
\begin{equation}
A_{+} = A_{Y+} A_{L+} = 
\left(\begin{array}{cccccc}
 w_\alpha(0) & 0 & 0 & \cdots & 0 & v_\alpha(0)\\
 u_\alpha(1) & w_\alpha(1) & 0 & \cdots & 0 & 0\\
 0 & u_\alpha(2) & w_\alpha(2) & \cdots & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
 0 & 0 & 0 & \cdots & w_\alpha(L_s-2) & 0\\
 0 & 0 & 0 & \cdots & u_\alpha(L_s-1) & w_\alpha(L_s-1)
\end{array}\right),
\end{equation}
\begin{equation}
A_{L+} =
\left(\begin{array}{cccccc}
 1 & 0 & 0 & \cdots & 0 & 0\\
 u_\alpha(1) & w_\alpha(1) & 0 & \cdots & 0 & 0\\
 0 & u_\alpha(2) & w_\alpha(2) & \cdots & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots  \\
 0 & 0 & 0 & \cdots & w_\alpha(L_s-2) & 0\\
 0 & 0 & 0 & \cdots & u_\alpha(L_s-1) & w_\alpha(L_s-1)
\end{array}\right),
\end{equation}
\begin{equation}
A_{Y+} =
\left(\begin{array}{ccccc}
1/z^{(+)}_\alpha
 & a^{(+)}_\alpha(1)
 & \cdots
 & a^{(+)}_\alpha(Ls-2)
 & a^{(+)}_\alpha(Ls-1) \\
0 & 1 & \cdots & 0 & 0 \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
0 & 0 & \cdots & 1 & 0 \\
0 & 0 & \cdots & 0 & 1 
\end{array}\right).
\end{equation}
For the following it is convenient to define
\begin{eqnarray}
a^{(+)}_\alpha(Ls-1) &=& -\frac{v_\alpha(0)}{w_\alpha(L_s-1)}, \\
a^{(+)}_\alpha(k) &=& - \frac{a^{(+)}_\alpha(k+1)u_\alpha(k)}{w_\alpha(k)}, \\
z^{(+)}_\alpha & = & \frac{1}{w_\alpha(0)(1-a^{(+)}_\alpha(0))},\\
b^{(+)}_\alpha(k) &=& - \frac{u_\alpha(k)}{w_\alpha(k)}, \\
c^{(+)}_\alpha(k) &=& \frac{1}{w_\alpha(k)}.
\end{eqnarray}

Then algorithm~\ref{inv-upper} could be used to compute
$\phi\leftarrow A_+^{-1}\psi$.
\incmargin{20pt}
\begin{algorithm}
\SetKwData{Input}{input}
\KwIn{$z$, precomputed part of $A_{Y+}$}
\KwIn{$a$, precomputed part of $A_{Y+}$}
\KwIn{$b$, precomputed part of $A_{L+}$}
\KwIn{$c$, precomputed part of $A_{L+}$}
\KwIn{$\psi$, the right hand side}
\KwIn{$L_s$, flavor dimension}
\KwOut{$\phi$, the result}
\dontprintsemicolon
\Begin{
  $\eta\leftarrow\psi_0$\;
  $k\leftarrow1$\;
  \For{$k<L_s$}{
    $\eta \leftarrow \eta + a_k\psi_k$\;
    $k\leftarrow k + 1$\;
  }
  $\phi_0\leftarrow\eta\leftarrow z \eta$\;
  $k\leftarrow1$\;
  \For{$k<L_s$}{
     $\phi_k\leftarrow\eta\leftarrow b_k \eta + c_k \psi_k$\;
     $k\leftarrow k + 1$\;
  }
  \Return{$\phi$}.
}
\caption{\label{inv-upper}Computing the inverse of $A_+$.}
\end{algorithm}
\decmargin{20pt}

For $A_{-}$ we have the following (once again, $B_{-}$ is similar.)
\begin{equation}
A_{-} = A_{Y-} A_{L-} = 
\left(\begin{array}{cccccc}
 w_\alpha(0) & u_\alpha(0) & 0 & \cdots & 0 & 0\\
 0 & w_\alpha(1) & u_\alpha(1) & \cdots & 0 & 0\\
 0 & 0 & w_\alpha(2) & \cdots & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
 0 & 0 & 0 & \cdots & w_\alpha(L_s-2) & u_\alpha(L_s-2)\\
 v_\alpha(L_s-1) & 0 & 0 & \cdots & 0 & w_\alpha(L_s-1)
\end{array}\right),
\end{equation}
\begin{equation}
A_{L-} =
\left(\begin{array}{cccccc}
 w_\alpha(0) & u_\alpha(0) & 0 & \cdots & 0 & 0\\
 0 & w_\alpha(1) & u_\alpha(1) & \cdots & 0 & 0\\
 0 & 0 & w_\alpha(2) & \cdots & 0 & 0\\
 \vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
 0 & 0 & 0 & \cdots & w_\alpha(L_s-2) & u_\alpha(L_s-2)\\
 0 & 0 & 0 & \cdots & 0 & 1
\end{array}\right),
\end{equation}
\begin{equation}
A_{Y-} = \left(\begin{array}{ccccc}
1 & 0 & \cdots & 0 & 0 \\
0 & 1 & \cdots & 0 & 0 \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
0 & 0 & \cdots & 1 & 0 \\
 a^{(-)}_\alpha(0) &
 a^{(-)}_\alpha(1) &
 \cdots
 a^{(-)}_\alpha(L_s-2) &
 1/z^{(-)}_\alpha 
\end{array}\right).
\end{equation}
Once again, it is convenient to define
\begin{eqnarray}
a^{(-)}_\alpha(0) &=& -\frac{v_\alpha(L_s-1)}{w_\alpha(0)}, \\
a^{(-)}_\alpha(k) &=& - \frac{a^{(-)}_\alpha(k-1)u_\alpha(k-1)}{w_\alpha(k)}, \\
z^{(-)}_\alpha & = & \frac{1}{w_\alpha(L_s-1)(1-a^{(-)}_\alpha(L_s-1))},\\
b^{(-)}_\alpha(k) &=& - \frac{u_\alpha(k)}{w_\alpha(k)}, \\
c^{(-)}_\alpha(k) &=& \frac{1}{w_\alpha(k)}.
\end{eqnarray}

Then algorithm~\ref{inv-lower} could be used to compute
$\phi\leftarrow A_-^{-1}\psi$.
\incmargin{20pt}
\begin{algorithm}
\SetKwData{Input}{input}
\KwIn{$z$, precomputed part of $A_{Y-}$}
\KwIn{$a$, precomputed part of $A_{Y-}$}
\KwIn{$b$, precomputed part of $A_{L-}$}
\KwIn{$c$, precomputed part of $A_{L-}$}
\KwIn{$\psi$, the right hand side}
\KwIn{$L_s$, flavor dimension}
\KwOut{$\phi$, the result}
\dontprintsemicolon
\Begin{
  $\eta\leftarrow\psi_{L_s-1}$\;
  $k\leftarrow0$\;
  \For{$k<L_s-1$}{
    $\eta \leftarrow \eta + a_k\psi_k$\;
    $k\leftarrow k + 1$\;
  }
  $\phi_{L_s-1}\leftarrow\eta\leftarrow z \eta$\;
  $k\leftarrow L_s-2$\;
  \For{$k\ge 0$}{
     $\phi_k\leftarrow\eta\leftarrow b_k \eta + c_k \psi_k$\;
     $k\leftarrow k - 1$\;
  }
  \Return{$\phi$}.
}
\caption{\label{inv-lower}Computing the inverse of $A_-$.}
\end{algorithm}
\decmargin{20pt}

\section{Combinations of $A$ and $B$}
With the notations above one can write other $s$-pieces we need:
\begin{eqnarray}
A^{-1} & = & A_{X+}^{-1}A_{L+}^{-1}P_{+}+A_{X-}^{-1}A_{L-}^{-1}P_{-}\\
A^{-1} & = & A_{L+}^{-1}A_{Y+}^{-1}P_{+}+A_{L-}^{-1}A_{Y-}^{-1}P_{-}\\
B^{-1} & = & B_{X+}^{-1}B_{L+}^{-1}P_{+}+B_{X-}^{-1}B_{L-}^{-1}P_{-}\\
B^{-1} & = & B_{L+}^{-1}B_{Y+}^{-1}P_{+}+B_{L-}^{-1}B_{Y-}^{-1}P_{-}\\
A_{+} & = & A_{L+} A_{X+} \\
A_{+} & = & A_{Y+} A_{L+} \\
A_{-} & = & A_{L-} A_{X-} \\
A_{-} & = & A_{Y-} A_{L-} \\
B_{+} & = & B_{L+} B_{X+} \\
B_{+} & = & B_{Y+} B_{L+} \\
B_{-} & = & B_{L-} B_{X-} \\
B_{-} & = & B_{Y-} B_{L-} \\
A^\dagger &=& A_{+}^\dagger P_{+}+ A_{-}^\dagger P_{-}\\
B^\dagger &=& B_{+}^\dagger P_{+}+ B_{-}^\dagger P_{-}\\
\end{eqnarray}

\chapter{ALGORITHMS}
\section{Conjugate gradient}
The equation
\[
   M^\dagger M \xi = \chi
\]
can be solve by the conjugate gradient method if the condition number of
 $M^\dagger M$ is small enough.
\incmargin{20pt}
\begin{algorithm}
\SetKwData{Input}{input}
\KwIn{$M$, the matrix}
\KwIn{$\chi$, the right hand side of the linear equation}
\KwIn{$\xi_0$, an initial guess}
\KwIn{$n$, the maximum number of iterations}
\KwIn{$\epsilon$, required precision}
\KwOut{$\xi$, approximate solution}
\KwOut{$r$, final residue}
\KwOut{$k$, number of iterations used}
\SetKw{Break}{break}
\dontprintsemicolon
\Begin{
  $\xi\leftarrow \xi_0$\;
  $\rho\leftarrow \chi - M^{\dagger}M\xi$\;
  $\pi\leftarrow \rho$\;
  $r\leftarrow\langle \rho,\rho\rangle$\;
  $k\leftarrow 0$\;
  \While{$r > \epsilon$ or $k < n$}{
    $\omega\leftarrow Mp$\;
    $\zeta\leftarrow M^{\dagger}\omega$\;
    $a\leftarrow r/\langle \omega,\omega\rangle$\;
    $\rho\leftarrow \rho - a \zeta$\;
    $ g \leftarrow \langle \rho,\rho\rangle$\;
    \If{$ g<\epsilon$}{
       $\xi\leftarrow \xi+ a \pi$\;
       $r \leftarrow g$\;
       \Break}
    $b\leftarrow g/r$\;
    $r\leftarrow g$\;
    $\xi\leftarrow \xi + a \pi$\;
    $\pi\leftarrow \rho + b \pi$\;
    $k\leftarrow k + 1$\;
  }
  \Return {$\xi$, $r$, $k$}.
}
\caption{\label{real}Conjugate Gradient Solver.}
\end{algorithm}
\decmargin{20pt}

\section{Shifted Conjugate Gradient}
We also need the ability to solve equations $(A+s_n I)\xi_n = \chi$,
$A=M^\dagger M$
for several $s_n$ and the same RHS $\chi$. It is possible to do this with
little extra work because Krylov's spaces of $A$ and $A+s_n I$ are the
same. We assume that the solution of $A\xi=\chi$ is also needed and that
 $s_n>0$ for all $n$.
% Under these assumptions the following algorithm
could be used.
For the details of the algorithm see van~der~Eshof and Sleijpen,~2003.
Notice that SCG always starts with $\xi_0=0$.

\incmargin{20pt}
\begin{algorithm}
\SetKwData{Input}{input}
\KwIn{$M$, the matrix}
\KwIn{$s[m]$, the vector of shifts}
\KwIn{$\chi$, the right hand side}
\KwIn{$n$, the maximal number of iterations}
\KwIn{$\epsilon$, required precision for $\sigma=0$}
\KwOut{$\xi[m]$, vector of approximate solutions}
\KwOut{$\xi$, approximate solution for $\sigma=0$}
\KwOut{$r$, final residue for $s=0$}
\KwOut{$k$, number of iterations used}
\SetKw{Break}{break}
\dontprintsemicolon
\Begin{
  $k\leftarrow 0$\;
  $\xi\leftarrow 0$\;
  $\rho \leftarrow \pi \leftarrow \chi$\;
  $r \leftarrow \langle \rho,\rho \rangle$\;
  $a_{-1}\leftarrow b_{-1}\leftarrow 1$\;
  \lForEach{$i$}{$\xi[i]\leftarrow 0$\;}
  \lForEach{$i$}{$\pi[i]\leftarrow \rho$\;}
  \lForEach{$i$}{$d_{-1}[i]\leftarrow d_{0}[i]\leftarrow 1$\;}
  \While{$k < n$}{
    $\omega\leftarrow M \pi$\;
    $z \leftarrow \langle \omega, \omega\rangle$\;
    $\zeta \leftarrow M^\dagger \omega$\;
    $a\leftarrow r / z$\;
    \lForEach{$i$}{$d_{1}[i]\leftarrow d_{0}[i]*(1+a*s[i])+
               a*b_{-1}*(d_{0}[i]-d_{-1}[i])/a_{-1}$\;}
    $\rho\leftarrow \rho - a * \zeta$\;
    $g \leftarrow \langle \rho,\rho \rangle$\;
    $b\leftarrow g / r$\;
    $r\leftarrow g$\;
    \If{$ r<\epsilon$}{
        $\xi\leftarrow \xi + a * \pi$\;
        \lForEach{$i$}{$\xi[i]\leftarrow \xi[i] + (a / d_1[i]) * \pi[i]$\;}
        \Break}
    $\xi\leftarrow \xi + a * \pi$\;
    \lForEach{$i$}{$\xi[i]\leftarrow \xi[i] + (a / d_1[i]) * \pi[i]$\;}
    $\pi\leftarrow \rho + b * \pi$\;
    \lForEach{$i$}{$\pi[i]\leftarrow \rho+ (b*d_0[i]/d_{1}[i])*\pi[i]$\;}
    \lForEach{$i$}{$d_{-1}[i]\leftarrow d_{0}[i]$\;}
    \lForEach{$i$}{$d_{0}[i]\leftarrow d_{1}[i]$\;}
    $b_{-1}\leftarrow b$\;
    $a_{-1}\leftarrow a$\;
    $k\leftarrow k+1$\;
  }
  \Return {$\xi[m]$, $\xi$, $r$, $k$}.
}
\caption{\label{shifted}Shifted Conjugate Gradient Solver.}
\end{algorithm}
\decmargin{20pt}

\chapter{INTERFACE}
The MDWF interface is fully functional to isolate users of the code from
implementation details. Several types defined in the interface provide help
with typechecking.
<<File [[../port/qop-mdwf3.h]]>>=
#ifndef QOP_MDWF_0bd50d0caeec4311a0d7c183032c43c2
# define `QOP_MDWF_0bd50d0caeec4311a0d7c183032c43c2
  <<Interface macros>>
  <<Interface types>>
  <<Interface functions>>
# if defined(QOP_MDWF_DEFAULT_PRECISION) && (QOP_MDWF_DEFAULT_PRECISION == 'F')
   <<Single precision defaults>>
# endif
# if defined(QOP_MDWF_DEFAULT_PRECISION) && (QOP_MDWF_DEFAULT_PRECISION == 'D')
    <<Double precision defaults>>
# endif
#endif
@

\section{Magic numbers}
The numbers below are provided as names for magic numbers in the code. They can
not be safely changed.

First, the dimension is always four:
<<Interface macros>>=
#define `QOP_MDWF_DIM 4
@

Next, the number of components in the Dirac fermion and the projected fermion
<<Interface macros>>=
#define `QOP_MDWF_FERMION_DIM 4
#define `QOP_MDWF_PROJECTED_FERMION_DIM 2
@

We work only with $SU(3)$
<<Interface macros>>=
#define `QOP_MDWF_COLORS 3
@

\section{Library version}
The following function returns a version of the library. The goal is to
provide enough information to uniquely identify library's version. Since
there are many features packed into the library, a human-readable string is
returned.
<<Interface functions>>=
const char *`QOP_MDWF_version(void);
@

\section{Performance monitoring}
Each interface function records its exectution time and number of floating point
operations in the [[State]] structure. These numbers are accessed via the
following function. Only data on the current node is recorded. The function
returns [[0]] if performance counters are updated.
<<Interface functions>>=
int `QOP_MDWF_performance(double *time_sec,
                         long long *flops,
                         long long *sent,
                         long long *receive,
                         struct QOP_MDWF_State *state);
@

\section{Initialization}
All library state is incapsulated into an opaque structure. We do not need
to expose any components of the structure to the user.
<<Interface types>>=
struct `QOP_MDWF_State;
@

We also need an opaque type for parameters of the domain wall action.
<<Interface types>>=
struct `QOP_MDWF_Parameters;
@

The library initialization routine creates the state structure and fills it
with necessary information. It returns [[0]] if successful and a non-zero value
otherwise. In any case [[state_ptr]] is set to some value suitable for other
library functions.
<<Interface functions>>=
int `QOP_MDWF_init(struct QOP_MDWF_State **state_ptr,
                  const int lattice[QOP_MDWF_DIM + 1],
                  const int network[QOP_MDWF_DIM],
		  const int node[QOP_MDWF_DIM],
	          int master_p,
                  void (*sublattice)(int lo[],
	                             int hi[],
                                     const int node[],
                                     void *env),
                  void *env);
@
Arguments of [[init()]] are
\begin{itemize}
\item[\texttt{state\_ptr}] points to the [[State]] to be set.
\item[\texttt{lattice}] 5--d lattice geometry. $L_s$ is [[lattice[4]]].
\item[\texttt{network}] 4--d network geometry. Each element should be positive.
\item[\texttt{node}] 4--d address of this node.
\item[\texttt{master\_p}] is non-zero on the master node, zero otherwise.
\item[\texttt{sublattice}] Function giving sublattice dimensions on an arbitrary node.
\item[\texttt{env}] Common environment for [[sublattice()]].
\end{itemize}

When [[QOP_MDWF_init()]] returns, [[*state_ptr]] will point to a valid
state of the library (if any error occurs during initialization, the
error will be stored in [[*ptr]]. The [[lattice[]]] provides the total
lattice size, and [[sublattice]] is a pointer to a function that given
a 4-d node address [[node]] returns in
[[lo]] and [[hi]] the sublattice coordinates local to the [[node]], in
effect saying that the local sublattice starts at [[x[i]=lo[i]]] and
ends at [[x[i]=hi[i]-1]].

It is possible to call [[QOP_MDWF_init()]] multiple times with different
arguments. The library does not require that the lattice size and layout agree
in different calls.

\section{Cleanup}
When the state is no longer needed it should be closed by the following function
<<Interface functions>>=
void `QOP_MDWF_fini(struct QOP_MDWF_State **state_ptr);
@
It is an error to use [[*state_ptr]] after it was closed. To help in error
detection this function sets [[*state_ptr]] to [[NULL]]. All library functions
check if the state they are passed is [[NULL]] and abort if it is.

\section{Errors}
When something goes wrong in the library, a library function will return some
non-zero value and store the error code in the library state. The error codes
are accessible as human-readable strings via the following function:
<<Interface functions>>=
const char *`QOP_MDWF_error(struct QOP_MDWF_State *state);
@
Note that the first error will be latched until [[QOP_MDWF_error()]] is called.
This is a design choice made to help in pinpointing the origin of the problem
when something goes wrong intead of reporting spiritious errors if multiple
calls to the library are made before an error is checked for. If there is no
error, [[QOP_MDWF_error()]] returns [[NULL]]. The function could be called
multiple times, it does not reset the error code, instead it marks in the state
that the error was reported thus allowing latching another error.

\section{Parameter setting}
Following functions set parameters of the MDWF into the state. These functions
allocate [[QOP_MDWF_Parameters]] structure.
<<Interface functions>>=
int `QOP_MDWF_set_generic(struct QOP_MDWF_Parameters **param_ptr,
                         struct QOP_MDWF_State *state,
                         const double b_5[],
                         const double c_5[],
                         double M_5,
                         double m);
@

As a convenience, specialized setups are provided as well.
For M\"obius fermions, $b_5(s) + c_5(s)=\kappa$:
<<Interface functions>>=
int `QOP_MDWF_set_Moebius(struct QOP_MDWF_Parameters **param_ptr,
                         struct QOP_MDWF_State *state,
                         const double b_5[],
                         double kappa,
                         double M_5,
                         double m);
@

For Shamir fermions, $b_5(s)=a_5$, $c_5=0$:
<<Interface functions>>=
int `QOP_MDWF_set_Shamir(struct QOP_MDWF_Parameters **param_ptr,
                        struct QOP_MDWF_State *state,
                        double a_5,
                        double M_5,
                        double m);
@

For Bori\c ci, $b_5(s)=c_5(s)=a_5$:
<<Interface functions>>=
int `QOP_MDWF_set_Borichi(struct QOP_MDWF_Parameters **param_ptr,
                         struct QOP_MDWF_State *state,
                         double a_5,
                         double M_5,
                         double m);
@

For Chiu, $b_5(s)=c_5(s)=a_5(s)$:
<<Interface functions>>=
int `QOP_MDWF_set_Chiu(struct QOP_MDWF_Parameters **param_ptr,
                      struct QOP_MDWF_State *state,
                      const double a_5[],
                      double M_5,
                      double m);
@
We also provide a corresponding destructor for [[QOP_MDWF_Parameters]]. This
function will write [[NULL]] back to the pointer to help in bug detection.
<<Interface functions>>=
void `QOP_MDWF_free_parameters(struct QOP_MDWF_Parameters **param_ptr);
@

\section{Gauge}
Any gauge field should be imported into the library format before it could
be used. To keep the interface as general as possible, we use a query function
approach for inport. There are two versions of [[QOP_MDWF_import_gauge]], one
for double precision, another for single precision.
<<Interface functions>>=
int `QOP_F3_MDWF_import_gauge(struct QOP_F3_MDWF_Gauge **gauge_ptr,
                             struct QOP_MDWF_State *state,
                             double (*reader)(int dir,
                                              const int pos[4],
                                              int a,
                                              int b,
                                              int re_im,
                                              void *env),
                             void *env);
int `QOP_D3_MDWF_import_gauge(struct QOP_D3_MDWF_Gauge **gauge_ptr,
                             struct QOP_MDWF_State *state,
                             double (*reader)(int dir,
                                              const int pos[4],
                                              int a,
                                              int b,
                                              int re_im,
                                              void *env),
			     void *env);
@
The [[reader()]] points to a function that provides a value of the gauge field
at a given point on the lattice, e.g., it returns the value of
[[U[dir][pos][a][b].re]] for [[re_im==0]] and 
[[U[dir][pos][a][b].im]] for [[re_im==1]]. If will be called only for [[pos]] in
a local sublattice. The [[reader()]] function is passed the [[env]] parameter
that may be used to access the guage field from the outer space.  The [[env]]
parameter is not used by [[import_gauge()]] functions for any other purpose.

If the function succeeds then the [[*gauge_ptr]] will be initialized to a value
that may be passed to other library functions. If something goes wrong,
[[*gauge_ptr]] will be set to [[NULL]].

Here are corresponding opaque types:
<<Interface types>>=
struct `QOP_F3_MDWF_Gauge;
struct `QOP_D3_MDWF_Gauge;
@

We also need a couple of destructors for gauge fields. For convenience, they
will accept [[NULL]] intead of a valid gauge field.
<<Interface functions>>=
void `QOP_F3_MDWF_free_gauge(struct QOP_F3_MDWF_Gauge **gauge_ptr);
void `QOP_D3_MDWF_free_gauge(struct QOP_D3_MDWF_Gauge **gauge_ptr);
@

Here are macros defining default values for gauge field types and functions:
<<Single precision defaults>>=
#define `QOP_MDWF_import_gauge QOP_F3_MDWF_import_gauge
#define `QOP_MDWF_free_gauge QOP_F3_MDWF_free_gauge
#define `QOP_MDWF_Gauge QOP_F3_MDWF_Gauge
@
<<Double precision defaults>>=
#define `QOP_MDWF_import_gauge QOP_D3_MDWF_import_gauge
#define `QOP_MDWF_free_gauge QOP_D3_MDWF_free_gauge
#define `QOP_MDWF_Gauge QOP_D3_MDWF_Gauge
@

\section{Fermions}
Unlike the gauge field, fermions are provided with a richer set of functions.
In addition to import and destruction, they could be created empty and exported.
<<Interface functions>>=
int `QOP_F3_MDWF_import_fermion(struct QOP_F3_MDWF_Fermion **fermion_ptr,
                               struct QOP_MDWF_State *state,
                               double (*reader)(const int pos[5],
                                                int color,
                                                int dirac,
                                                int re_im,
                                                void *env),
                               void *env);
int `QOP_D3_MDWF_import_fermion(struct QOP_D3_MDWF_Fermion **fermion_ptr,
                               struct QOP_MDWF_State *state,
                               double (*reader)(const int pos[5],
                                                int color,
                                                int dirac,
                                                int re_im,
                                                void *env),
                               void *env);
@
The [[reader()]] points to a function that provides a value of the fermion field
at a given point on the lattice, e.g., it returns the value of
[[F[pos][color][dirac].re]] for [[re_im==0]] and 
[[F[pos][color][dirac].im]] for [[re_im==1]].
If will be called only for [[pos]] in
a local sublattice. The [[env]] parameter
is passed blindly to the [[reader()]] without any interpretation whatsoever. It
could be used to access the fermion field from the outer space or for any other
purpose.

If the function succeeds then the [[*fermion_ptr]] will be initialized to a
value that may be passed to other library functions. If something goes wrong,
[[*fermion_ptr]] will be set to [[NULL]].

Here are corresponding opaque types:
<<Interface types>>=
struct `QOP_F3_MDWF_Fermion;
struct `QOP_D3_MDWF_Fermion;
@

One may also need to create a fermion field without any useful initial value.
For convenience, we provide functions to do that
<<Interface functions>>=
int `QOP_F3_MDWF_allocate_fermion(struct QOP_F3_MDWF_Fermion **fermion_ptr,
                                 struct QOP_MDWF_State *state);
int `QOP_D3_MDWF_allocate_fermion(struct QOP_D3_MDWF_Fermion **fermion_ptr,
                                 struct QOP_MDWF_State *state);
@

Unlike the gauge fields, fermions need a way to be exported back to the user.
We also use a functional interface to provide indexing.
<<Interface functions>>=
int `QOP_F3_MDWF_export_fermion(void (*writer)(const int pos[5],
                                              int color,
                                              int dirac,
                                              int re_im,
                                              double value,
                                              void *env),
                               void *env,
                               const struct QOP_F3_MDWF_Fermion *fermion);
int `QOP_D3_MDWF_export_fermion(void (*writer)(const int pos[5],
                                              int color,
                                              int dirac,
                                              int re_im,
                                              double value,
                                              void *env),
                               void *env,
                               const struct QOP_D3_MDWF_Fermion *fermion);
@

We also need a couple of destructors for fermion fields. For convenience, they
will accept [[NULL]] intead of a valid fermion field.
<<Interface functions>>=
void `QOP_F3_MDWF_free_fermion(struct QOP_F3_MDWF_Fermion **fermion_ptr);
void `QOP_D3_MDWF_free_fermion(struct QOP_D3_MDWF_Fermion **fermion_ptr);
@

Finally, macros for prefered precision
<<Single precision defaults>>=
#define `QOP_MDWF_import_fermion QOP_F3_MDWF_import_fermion
#define `QOP_MDWF_export_fermion QOP_F3_MDWF_export_fermion
#define `QOP_MDWF_allocate_fermion QOP_F3_MDWF_allocate_fermion
#define `QOP_MDWF_free_fermion QOP_F3_MDWF_free_fermion
#define `QOP_MDWF_Fermion QOP_F3_MDWF_Fermion
@
<<Double precision defaults>>=
#define `QOP_MDWF_import_fermion QOP_D3_MDWF_import_fermion
#define `QOP_MDWF_export_fermion QOP_D3_MDWF_export_fermion
#define `QOP_MDWF_allocate_fermion QOP_D3_MDWF_allocate_fermion
#define `QOP_MDWF_free_fermion QOP_D3_MDWF_free_fermion
#define `QOP_MDWF_Fermion QOP_D3_MDWF_Fermion
@

\section{Preconditioned fermions}
We also need preconditioned fermions. They exist in parallel to full fermions
but the exact relation is not specified.
Unlike the gauge field, fermions are provided with a richer set of functions.
In addition to import and destruction, they could be created empty and exported.
<<Interface functions>>=
int `QOP_F3_MDWF_import_half_fermion(struct QOP_F3_MDWF_HalfFermion **hfermion_ptr,
                                    struct QOP_MDWF_State *state,
                                    double (*reader)(const int pos[5],
                                                     int color,
                                                     int dirac,
                                                     int re_im,
                                                     void *env),
                                    void *env);
int `QOP_D3_MDWF_import_half_fermion(struct QOP_D3_MDWF_HalfFermion **hfermion_ptr,
                                    struct QOP_MDWF_State *state,
                                    double (*reader)(const int pos[5],
                                                     int color,
                                                     int dirac,
                                                     int re_im,
                                                     void *env),
                                    void *env);
@
The [[reader()]] points to a function that provides a value of the
preconditioned fermion field
at a given point on the lattice, e.g., it returns the value of
[[F[pos][color][dirac].re]] for [[re_im==0]] and 
[[F[pos][color][dirac].im]] for [[re_im==1]].
If will be called only for [[pos]] in
a local sublattice. The [[env]] parameter
is passed blindly to the [[reader()]] without any interpretation whatsoever. It
could be used to access the half fermion in the calling layer.

If the function succeeds then the [[*hfermion_ptr]] will be initialized to a
value that may be passed to other library functions. If something goes wrong,
[[*hfermion_ptr]] will be set to [[NULL]].

Here are corresponding opaque types:
<<Interface types>>=
struct `QOP_F3_MDWF_HalfFermion;
struct `QOP_D3_MDWF_HalfFermion;
@

One may also need to create a fermion field without any useful initial value.
For convenience, we provide functions to do that
<<Interface functions>>=
int `QOP_F3_MDWF_allocate_half_fermion(struct QOP_F3_MDWF_HalfFermion **hfermion_ptr,
                                      struct QOP_MDWF_State *state);
int `QOP_D3_MDWF_allocate_half_fermion(struct QOP_D3_MDWF_HalfFermion **hfermion_ptr,
                                      struct QOP_MDWF_State *state);
@

Preconditioned fermions may be exported back to the user.
We also use a functional interface to provide indexing.
<<Interface functions>>=
int `QOP_F3_MDWF_export_half_fermion(void (*writer)(const int pos[5],
                                                   int color,
                                                   int dirac,
                                                   int re_im,
                                                   double value,
                                                   void *env),
                                   void *env,
                                   const struct QOP_F3_MDWF_HalfFermion *hfermion);
int `QOP_D3_MDWF_export_half_fermion(void (*writer)(const int pos[5],
                                                   int color,
                                                   int dirac,
                                                   int re_im,
                                                   double value,
                                                   void *env),
                                   void *env,
                                   const struct QOP_D3_MDWF_HalfFermion *hfermion);
@

We also need a couple of destructors for fermion fields. For convenience, they
will accept [[NULL]] intead of a valid fermion field.
<<Interface functions>>=
void `QOP_F3_MDWF_free_half_fermion(struct QOP_F3_MDWF_HalfFermion **hfermion_ptr);
void `QOP_D3_MDWF_free_half_fermion(struct QOP_D3_MDWF_HalfFermion **hfermion_ptr);
@

Finally, macros for prefered precision
<<Single precision defaults>>=
#define `QOP_MDWF_import_half_fermion QOP_F3_MDWF_import_half_fermion
#define `QOP_MDWF_export_half_fermion QOP_F3_MDWF_export_half_fermion
#define `QOP_MDWF_allocate_half_fermion QOP_F3_MDWF_allocate_half_fermion
#define `QOP_MDWF_free_half_fermion QOP_F3_MDWF_free_half_fermion
#define `QOP_MDWF_HalfFermion QOP_F3_MDWF_HalfFermion
@
<<Double precision defaults>>=
#define `QOP_MDWF_import_half_fermion QOP_D3_MDWF_import_half_fermion
#define `QOP_MDWF_export_half_fermion QOP_D3_MDWF_export_half_fermion
#define `QOP_MDWF_allocate_half_fermion QOP_D3_MDWF_allocate_half_fermion
#define `QOP_MDWF_free_half_fermion QOP_D3_MDWF_free_half_fermion
#define `QOP_MDWF_HalfFermion QOP_D3_MDWF_HalfFermion
@

\section{Fermion Vectors}
For shifted conjugate gradient solver we need vectors of preconditioned
fermions. To the user only an opaque data type is presented.
<<Interface types>>=
struct QOP_F3_MDWF_VectorFermion;
struct QOP_D3_MDWF_VectorFermion;
@

 First, the allocator. It takes a number of elements in the vector and
returns an opaque vector fermion object.
<<Interface functions>>=
int `QOP_F3_MDWF_allocate_vector_fermion(struct QOP_F3_MDWF_VectorFermion **vf_ptr,
                                        struct QOP_MDWF_State *state,
                                        int n);
int `QOP_D3_MDWF_allocate_vector_fermion(struct QOP_D3_MDWF_VectorFermion **vf_ptr,
                                       struct QOP_MDWF_State *state,
                                       int n);
@
Destructors of the vector fermions accept [[NULL]] in addition to a valid vector fermion pointer.
<<Interface functions>>=
void `QOP_F3_MDWF_free_vector_fermion(struct QOP_F3_MDWF_VectorFermion **vf_ptr);
void `QOP_D3_MDWF_free_vector_fermion(struct QOP_D3_MDWF_VectorFermion **vf_ptr);
@

We also provide primitive access procedures (mnemonic convention is
``get from vector'' and ``put into vector''):
<<Interface functions>>=
int `QOP_F3_MDWF_get_vector_fermion(struct QOP_F3_MDWF_HalfFermion *hf,
                                   const struct QOP_F3_MDWF_VectorFermion *vf,
 	  	  	           int index);
int `QOP_D3_MDWF_get_vector_fermion(struct QOP_D3_MDWF_HalfFermion *hf,
                                   const struct QOP_D3_MDWF_VectorFermion *vf,
 	  		           int index);
int `QOP_F3_MDWF_put_vector_fermion(struct QOP_F3_MDWF_VectorFermion *vf,
                                   int index,
                                   const struct QOP_F3_MDWF_HalfFermion *hf);
int `QOP_D3_MDWF_put_vector_fermion(struct QOP_D3_MDWF_VectorFermion *vf,
                                   int index,
                                   const struct QOP_D3_MDWF_HalfFermion *hf);
@

Macros for default precision:
<<Single precision defaults>>=
#define `QOP_MDWF_allocate_vector_fermion QOP_F3_MDWF_allocate_vector_fermion
#define `QOP_MDWF_free_vector_fermion QOP_F3_MDWF_free_vector_fermion
#define `QOP_MDWF_get_vector_fermion QOP_F3_MDWF_get_vector_fermion
#define `QOP_MDWF_put_vector_fermion QOP_F3_MDWF_put_vector_fermion
#define `QOP_MDWF_VectorFermion QOP_F3_MDWF_VectorFermion
@
<<Double precision defaults>>=
#define `QOP_MDWF_allocate_vector_fermion QOP_D3_MDWF_allocate_vector_fermion
#define `QOP_MDWF_free_vector_fermion QOP_D3_MDWF_free_vector_fermion
#define `QOP_MDWF_get_vector_fermion QOP_D3_MDWF_get_vector_fermion
#define `QOP_MDWF_put_vector_fermion QOP_D3_MDWF_put_vector_fermion
#define `QOP_MDWF_VectorFermion QOP_D3_MDWF_VectorFermion
@

\section{Dirac Operator}
We provide both normal and conjugated Dirac Operator for the full fermion as
well as the precondition operator and its conjugate both in single and double
precision.
<<Interface functions>>=
int `QOP_F3_MDWF_DDW_operator(struct QOP_F3_MDWF_Fermion *result,
                             const struct QOP_MDWF_Parameters *params,
	 		     const struct QOP_F3_MDWF_Gauge *gauge,
		 	     const struct QOP_F3_MDWF_Fermion *fermion);
int `QOP_D3_MDWF_DDW_operator(struct QOP_D3_MDWF_Fermion *result,
			     const struct QOP_MDWF_Parameters *params,
                             const struct QOP_D3_MDWF_Gauge *gauge,
			     const struct QOP_D3_MDWF_Fermion *fermion);
@
<<Interface functions>>=
int `QOP_F3_MDWF_DDW_operator_conjugated(struct QOP_F3_MDWF_Fermion *result,
	 	                        const struct QOP_MDWF_Parameters *params,
                                        const struct QOP_F3_MDWF_Gauge *gauge,
		 	                const struct QOP_F3_MDWF_Fermion *fermion);
int `QOP_D3_MDWF_DDW_operator_conjugated(struct QOP_D3_MDWF_Fermion *result,
                                        const struct QOP_MDWF_Parameters *params,
                                        const struct QOP_D3_MDWF_Gauge *gauge,
			                const struct QOP_D3_MDWF_Fermion *fermion);
@
<<Interface functions>>=
int `QOP_F3_MDWF_M_operator(struct QOP_F3_MDWF_HalfFermion *result,
	  	           const struct QOP_MDWF_Parameters *params,
                           const struct QOP_F3_MDWF_Gauge *gauge,
		 	   const struct QOP_F3_MDWF_HalfFermion *fermion);
int `QOP_D3_MDWF_M_operator(struct QOP_D3_MDWF_HalfFermion *result,
	 	           const struct QOP_MDWF_Parameters *params,
                           const struct QOP_D3_MDWF_Gauge *gauge,
			   const struct QOP_D3_MDWF_HalfFermion *fermion);
@
<<Interface functions>>=
int `QOP_F3_MDWF_M_operator_conjugated(struct QOP_F3_MDWF_HalfFermion *result,
	  	                      const struct QOP_MDWF_Parameters *params,
                                      const struct QOP_F3_MDWF_Gauge *gauge,
			              const struct QOP_F3_MDWF_HalfFermion *fermion);
int `QOP_D3_MDWF_M_operator_conjugated(struct QOP_D3_MDWF_HalfFermion *result,
	   	                      const struct QOP_MDWF_Parameters *params,
                                      const struct QOP_D3_MDWF_Gauge *gauge,
			              const struct QOP_D3_MDWF_HalfFermion *fermion);
@

Also the default precision macros
<<Single precision defaults>>=
#define `QOP_MDWF_DDW_operator QOP_F3_MDWF_DDW_operator
#define `QOP_MDWF_DDW_operator_conjugated QOP_F3_MDWF_DDW_operator_conjugated
#define `QOP_MDWF_M_operator QOP_F3_MDWF_M_operator
#define `QOP_MDWF_M_operator_conjugated QOP_F3_MDWF_M_operator_conjugated
@
<<Double precision defaults>>=
#define `QOP_MDWF_DDW_operator QOP_D3_MDWF_DDW_operator
#define `QOP_MDWF_DDW_operator_conjugated QOP_D3_MDWF_DDW_operator_conjugated
#define `QOP_MDWF_M_operator QOP_D3_MDWF_M_operator
#define `QOP_MDWF_M_operator_conjugated QOP_D3_MDWF_M_operator_conjugated
@

\section{Solvers}
We provide three solvers for the Dirac operator. All solvers can optionally
compute true CG and Dirac residuals on each iteration. Constants below can be
bitwise combined to select which residual are computed and printed. The
behavior of the solvers do not change when residuals are selected. Applications
should not assume particular values of the constants except that
[[QOP_MDWF_LOG_NONE]] is zero.
<<Interface types>>=
enum {
   `QOP_MDWF_LOG_NONE = 0,
   `QOP_MDWF_LOG_CG_RESIDUAL = 1,
   `QOP_MDWF_LOG_TRUE_RESIDUAL = 2,
   `QOP_MDWF_LOG_DIRAC_RESIDUAL = 4,
   `QOP_MDWF_FINAL_CG_RESIDUAL = 8,
   `QOP_MDWF_FINAL_DIRAC_RESIDUAL = 16,
   `QOP_MDWF_LOG_EVERYTHING = 31
};
@

First, the convenience routine to solve $D_{DW}\psi=\eta$. At most
[[max_iterations]] are performed, the CG stops when the iterative precontioned
residue becomes $\epsilon$ or less.
If conjugate gradient converges, zero is returned. In this case
[[out_iterations]] contains the number of iterations and [[out_epsilon]]
contains normalized iterative CG residual.

<<Interface functions>>=
int `QOP_F3_MDWF_DDW_CG(struct QOP_F3_MDWF_Fermion *result,
                       int *out_iterations,
                       double *out_epsilon,
                       const struct QOP_MDWF_Parameters *params,
                       const struct QOP_F3_MDWF_Fermion *chi_0,
                       const struct QOP_F3_MDWF_Gauge *gauge,
                       const struct QOP_F3_MDWF_Fermion *rhs,
                       int max_iteration,
                       double epsilon,
                       unsigned int options);
int `QOP_D3_MDWF_DDW_CG(struct QOP_D3_MDWF_Fermion *result,
                       int *out_iterations,
                       double *out_epsilon,
                       const struct QOP_MDWF_Parameters *params,
                       const struct QOP_D3_MDWF_Fermion *x_0,
                       const struct QOP_D3_MDWF_Gauge *gauge,
                       const struct QOP_D3_MDWF_Fermion *rhs,
                       int max_iteration,
                       double epsilon,
                       unsigned int options);
@

We also expose the preconditioned hermitian solver for
$M^\dagger M\psi_e=\phi_e$. In this case the CG starts from $\psi_e$.
If conjugate gradient converges, zero is returned. In this case
[[out_iterations]] contains the number of iterations and [[out_epsilon]]
contains normalized iterative CG residual.
<<Interface functions>>=
int `QOP_F3_MDWF_MxM_CG(struct QOP_F3_MDWF_HalfFermion *result,
                       int *out_iterations,
                       double *out_epsilon,
                       const struct QOP_MDWF_Parameters *params,
                       const struct QOP_F3_MDWF_Gauge *gauge,
                       const struct QOP_F3_MDWF_HalfFermion *rhs,
                       int max_iteration,
                       double epsilon,
                       unsigned int options);
int `QOP_D3_MDWF_MxM_CG(struct QOP_D3_MDWF_HalfFermion *result,
                       int *out_iterations,
                       double *out_epsilon,
                       const struct QOP_MDWF_Parameters *params,
                       const struct QOP_D3_MDWF_Gauge *gauge,
                       const struct QOP_D3_MDWF_HalfFermion *rhs,
                       int max_iteration,
                       double epsilon,
                       unsigned int options);
@

A collection of preconditioned equations with different positive shifts can be
solved with very little extra cost using Algorithm~\ref{shifted}.
<<Interface functions>>=
int `QOP_F3_MDWF_MxM_SCG(struct QOP_F3_MDWF_VectorFermion *vector_result,
                        struct QOP_F3_MDWF_HalfFermion *scalar_result,
                        int *out_iterations,
                        double *out_epsilon,
                        const struct QOP_MDWF_Parameters *params,
                        const double shift[],
                        const struct QOP_F3_MDWF_Gauge *gauge,
                        const struct QOP_F3_MDWF_HalfFermion *rhs,
                        int max_iterations,
                        double min_epsilon,
                        unsigned int options);
int `QOP_D3_MDWF_MxM_SCG(struct QOP_D3_MDWF_VectorFermion *vector_result,
                        struct QOP_D3_MDWF_HalfFermion *scalar_result,
                        int *out_iterations,
                        double *out_epsilon,
                        const struct QOP_MDWF_Parameters *params,
                        const double shift[],
                        const struct QOP_D3_MDWF_Gauge *gauge,
                        const struct QOP_D3_MDWF_HalfFermion *rhs,
                        int max_iterations,
                        double min_epsilon,
                        unsigned int options);
@

Again, macros
<<Single precision defaults>>=
#define `QOP_MDWF_DDW_CG QOP_F3_MDWF_DDW_CG
#define `QOP_MDWF_MxM_CG QOP_F3_MDWF_MxM_CG
#define `QOP_MDWF_MxM_SCG QOP_F3_MDWF_MxM_SCG
@
<<Double precision defaults>>=
#define `QOP_MDWF_DDW_CG QOP_D3_MDWF_DDW_CG
#define `QOP_MDWF_MxM_CG QOP_D3_MDWF_MxM_CG
#define `QOP_MDWF_MxM_SCG QOP_D3_MDWF_MxM_SCG
@

\section{Helper routines}
To avoid excessive export and import calls, we provide the following linear
algebra on full and preconditioned fermions.
\[
r\leftarrow a + \alpha b
\]
<<Interface functions>>=
int `QOP_F3_MDWF_madd_fermion(struct QOP_F3_MDWF_Fermion *r,
                             const struct QOP_F3_MDWF_Fermion *a,
                             double alpha,
                             const struct QOP_F3_MDWF_Fermion *b);
int `QOP_D3_MDWF_madd_fermion(struct QOP_D3_MDWF_Fermion *r,
                             const struct QOP_D3_MDWF_Fermion *a,
                             double alpha,
                             const struct QOP_D3_MDWF_Fermion *b);
int `QOP_F3_MDWF_madd_half_fermion(struct QOP_F3_MDWF_HalfFermion *r,
                                  const struct QOP_F3_MDWF_HalfFermion *a,
                                  double alpha,
                                  const struct QOP_F3_MDWF_HalfFermion *b);
int `QOP_D3_MDWF_madd_half_fermion(struct QOP_D3_MDWF_HalfFermion *r,
                                  const struct QOP_D3_MDWF_HalfFermion *a,
                                  double alpha,
                                  const struct QOP_D3_MDWF_HalfFermion *b);
@
\[
  \alpha \leftarrow \langle a,b\rangle
\]
<<Interface functions>>=
int `QOP_F3_MDWF_dot_fermion(double *r_re,
                            double *r_im,
                            const struct QOP_F3_MDWF_Fermion *a,
                            const struct QOP_F3_MDWF_Fermion *b);
int `QOP_D3_MDWF_dot_fermion(double *r_re,
                            double *r_im,
                            const struct QOP_D3_MDWF_Fermion *a,
                            const struct QOP_D3_MDWF_Fermion *b);
int `QOP_F3_MDWF_dot_half_fermion(double *r_re,
                                 double *r_im,
                                 const struct QOP_F3_MDWF_HalfFermion *a,
                                 const struct QOP_F3_MDWF_HalfFermion *b);
int `QOP_D3_MDWF_dot_half_fermion(double *r_re,
                                 double *r_im,
                                 const struct QOP_D3_MDWF_HalfFermion *a,
                                 const struct QOP_D3_MDWF_HalfFermion *b);
@

\[
  \alpha \leftarrow \langle a,a\rangle
\]
<<Interface functions>>=
int `QOP_F3_MDWF_norm2_fermion(double *r,
                              const struct QOP_F3_MDWF_Fermion *a);
int `QOP_D3_MDWF_norm2_fermion(double *r_re,
                              const struct QOP_D3_MDWF_Fermion *a);
int `QOP_F3_MDWF_norm2_half_fermion(double *r_re,
                                   const struct QOP_F3_MDWF_HalfFermion *a);
int `QOP_D3_MDWF_norm2_half_fermion(double *r_re,
                                   const struct QOP_D3_MDWF_HalfFermion *a);
@

Also, the macros
<<Single precision defaults>>=
#define `QOP_MDWF_madd_fermion QOP_F3_MDWF_madd_fermion
#define `QOP_MDWF_madd_half_fermion QOP_F3_MDWF_madd_half_fermion
#define `QOP_MDWF_dot_fermion QOP_F3_MDWF_dot_fermion
#define `QOP_MDWF_dot_half_fermion QOP_F3_MDWF_dot_half_fermion
#define `QOP_MDWF_norm2_fermion QOP_F3_MDWF_norm2_fermion
#define `QOP_MDWF_norm2_half_fermion QOP_F3_MDWF_norm2_half_fermion
@
<<Double precision defaults>>=
#define `QOP_MDWF_madd_fermion QOP_D3_MDWF_madd_fermion
#define `QOP_MDWF_madd_half_fermion QOP_D3_MDWF_madd_half_fermion
#define `QOP_MDWF_dot_fermion QOP_D3_MDWF_dot_fermion
#define `QOP_MDWF_dot_half_fermion QOP_D3_MDWF_dot_half_fermion
#define `QOP_MDWF_norm2_fermion QOP_D3_MDWF_norm2_fermion
#define `QOP_MDWF_norm2_half_fermion QOP_D3_MDWF_norm2_half_fermion
@

\chapter{CHANGES}
\begin{tabular}{|p{72pt}|l|p{350pt}|}
\hline
XXX & avp & Version 1.X.X. \\
\hline
May 17, 2008 & avp & Bug in error handling fixed. \\
\hline
May 15, 2008 & avp & Version 1.1.3. Bug in the docs fixed
                           (master node definition). \\
\hline
May 14, 2008 & avp & Version 1.1.2. Solvers set error in the state if they
                     do not converge. Samples print a helpful marker. \\
\hline
May 8, 2008 & avp & Version 1.1.1. A nasty bug in [[samples]] fixed.\\
\hline
May 7, 2008 & avp & Version 1.1.0. Shifted solver added, samples installed.\\
\hline
May 5, 2008 & avp & Version 1.0.1. Mixed precision bug fixed.\\
\hline
May 2, 2008 & avp & Version 1.0.0. \\
\hline
October 9, 2007 & avp & Initial version. \\
\hline
\end{tabular}

\appendix
\chapter{CODE CHUNKS}
\nowebchunks
\pagebreak
\chapter{SYMBOLS}
\nowebindex

\end{document}
