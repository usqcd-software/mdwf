\documentclass[twoside]{article}
\usepackage{noweb}
\noweboptions{externalindex,longchunks,longxref}
\usepackage{color}
\definecolor{darkblue}{cmyk}{1,1,0,0.7}
\usepackage[dvipdfm,colorlinks=true,linkcolor=darkblue]{hyperref}
\newcommand{\note}[1]{$[\![$NB: #1$]\!]$}
\newcommand{\idiv}{\,\mbox{\bf div}\,}
\newcommand{\imod}{\,\mbox{\bf mod}\,}
\newcommand{\iand}{\,\mbox{\bf and}\,}
\newcommand{\ior}{\,\mbox{\bf or}\,}
\newcommand{\ixor}{\,\mbox{\bf xor}\,}
\setlength{\parindent}{0pt}
\setlength{\topmargin}{-40pt}
\setlength{\oddsidemargin}{-16pt}
\setlength{\evensidemargin}{-16pt}
\setlength{\textwidth}{522pt}
\setlength{\textheight}{680pt}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\title{QA---Register Transfer Language}
\author{Andrew Pochinsky}
\catcode`\$=11
\date{$Id$}
\catcode`\$=3

\newcommand{\any}{${}^{*}$}
\newcommand{\oneplus}{${}^{+}$}
\newcommand{\nonterminal}[1]{$\langle$\emph{#1}$\rangle$}
\newcommand{\is}{&$\rightarrow$&&}
\newcommand{\also}{&&$|$&}
\newcommand{\terminal}[1]{\texttt{#1}}
\newcommand{\nothing}{\terminal{/* nothing */}}
\newenvironment{grammar}{\par\medskip\begin{tabular}{lccl}}{%
\end{tabular}\medskip\par}

\begin{document}
\maketitle
\section{GRAMMAR}
Here we define the grammar for QA. We start with the file level constructs:

\begin{grammar}
\nonterminal{qa0} \is \nonterminal{decl}\any\\
\nonterminal{decl}\is\nonterminal{alias}\\
  \also\nonterminal{constant}\\
  \also\nonterminal{structure}\\
  \also\nonterminal{array}\\
  \also\nonterminal{verbose} \\
  \also\nonterminal{include} \\
  \also\nonterminal{top level macro}\\
\nonterminal{top level macro}\is\nonterminal{procedure}\\
  \also\terminal{(} \terminal{repeat}
         \terminal{(} \nonterminal{iterator}\any \terminal{)}
         \nonterminal{top level macro}\oneplus \terminal{)}\\
\end{grammar}

The \nonterminal{include} directive inserts the contents of the file into the
input.
\begin{grammar}
\nonterminal{include}\is\terminal{(}\terminal{include} \nonterminal{file}
  \terminal{)}\\
\nonterminal{file}\is\nonterminal{string}
\end{grammar}


The \nonterminal{verbose} directive allows one to include literals into
various outputs:
\begin{grammar}
\nonterminal{verbose}\is\terminal{(}\terminal{verbose}
   \nonterminal{verbose case}\oneplus\terminal{)} \\
\nonterminal{verbose case}\is\terminal{(}
   \nonterminal{target} \nonterminal{verbose value} \terminal{)} \\
\nonterminal{target}\is\nonterminal{symbol}\\
\nonterminal{verbose data}\is\nonterminal{string}
\end{grammar}
The \nonterminal{target} selects the back-end that will see the corresponding
\nonterminal{vebose data}.

There are two kinds of iterators. One is an enumeration, another is loop-like
\begin{grammar}
\nonterminal{iterator}\is\terminal{(}
   \nonterminal{name} \terminal( \nonterminal{a-value}\oneplus \terminal)
     \terminal{)}\\
  \also\terminal{(}
   \nonterminal{name} \nonterminal{inclusive constant low}
      \nonterminal{exclusive constant high} \terminal{)}\\
\nonterminal{inclusive constant low}\is\nonterminal{constant expr}\\
\nonterminal{exclusive constant high}\is\nonterminal{constant expr}\\
\end{grammar}

Integer constants may be defined and given names. We do not specify the
allowed set of operations in \nonterminal{c-expr} here,
they will be introduced as needed.

\begin{grammar}
\nonterminal{constant}\is\terminal{(} \terminal{constant}
 \nonterminal{name} \nonterminal{constant expression}\terminal{)}\\
\nonterminal{constant expression}\is\terminal{(} \terminal{const}
  \nonterminal{c-expr} \terminal{)}\\
\nonterminal{c-expr}\is\nonterminal{number}\\
  \also\nonterminal{name}\\
  \also\nonterminal{string}\\
  \also\terminal{(} \nonterminal{c-op} \nonterminal{c-expr}\any\terminal{)}\\
\nonterminal{c-op}\is\nonterminal{symbol}\\
\nonterminal{name}\is\nonterminal{symbol}\\
\end{grammar}

Structure definitions provide a way to compute offsets to various elements
within a memory block. They also contain enough information to generate a
corresponding C declaration.

\begin{grammar}
\nonterminal{structure}\is\terminal{(} \terminal{structure}
 \nonterminal{external name}
   \terminal{(}\nonterminal{field}\oneplus\terminal{)}\terminal{)}\\
\nonterminal{field}\is\terminal{(} \nonterminal{external name}
  \nonterminal{type name} \terminal{)}\\
\nonterminal{external name}\is\nonterminal{name} \nonterminal{string}\\
\nonterminal{type name}\is\nonterminal{name}\\
\end{grammar}

Each \nonterminal{structure} definition provides the following set of
\nonterminal{c-expr}. First, there is \terminal{(size-of}
\nonterminal{structure name}\terminal{)} which computes the size
of the structure in bytes. It properly handles all alignment requirements for
parts of the structure and produces the same result as
\verb|sizeof (struct foo)| in C where \verb|foo| is the corresponding C tag.
Second, there is \terminal{(align-of} \nonterminal{structure name}\terminal{)}
computing the alignment of the structure in bytes. It is always a power of 2.
In addition, for each component of the structure, there is 
\terminal{(offset-of} \nonterminal{structure name}
\nonterminal{field name}\terminal{)}, which computes an offset from the
begining of the structure to the given field.

Array types are introduced with the following contruct:
\begin{grammar}
\nonterminal{array}\is\terminal{(} \terminal{array}
 \nonterminal{external name} \nonterminal{base type name}
     \nonterminal{constant expression}\terminal{)}\\
\nonterminal{base type name}\is\nonterminal{type name}
\end{grammar}

There is also a set of predefined types. At this stage we do not specify
them.

Constants, predefined types, arrays, and structures may be aliased. For
simplicity, we do not keep separate name spaces for them. All definitions are
checked for conflicts.
\begin{grammar}
\nonterminal{alias}\is\terminal{(} \terminal{alias}
 \nonterminal{new name} \nonterminal{old name}\terminal{)}\\
\nonterminal{new name}\is\nonterminal{name}\\
\nonterminal{old name}\is\nonterminal{name}\\
\end{grammar}

The last part of the top level structure is procedure. At this time we only
define leaf procedures. Since we need to generate multiple variants of the
procedures from the same sources, external names are generated from the
attributes. The internal names are not used in this version.

\begin{grammar}
\nonterminal{procedure}\is\terminal{(} \terminal{procedure}
  \nonterminal{name} \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{argument}\any \terminal{)}
  \nonterminal{code}\oneplus \terminal{)}\\
\nonterminal{argument}\is\terminal{(}
    \nonterminal{argument name} \nonterminal{type name}
    \nonterminal{C type} \nonterminal{C name} \terminal{)}\\
\nonterminal{argument name}\is\nonterminal{name}\\
\nonterminal{C type}\is\nonterminal{string}\\
\nonterminal{C name}\is\nonterminal{string}\\
\nonterminal{attribute}\is\nonterminal{name}\\
  \also\terminal{(} \nonterminal{name}
                  \nonterminal{a-value}\oneplus \terminal{)}\\
\nonterminal{a-value}\is\nonterminal{string}\\
   \also\nonterminal{number}\\
   \also\nonterminal{symbol}\\
\end{grammar}

The code is design to help with instruction generation and data flow analysis.
At this stage we keep regular loops and provide conditional branching. There is
no back branches or returns. We do not provide automatic variables since
there are only leaf procedures.

\begin{grammar}
\nonterminal{code}\is \nonterminal{operation}\\
  \also\nonterminal{memory access}\\
  \also\nonterminal{block}\\
  \also\nonterminal{loop}\\
  \also\nonterminal{conditional}\\
  \also\nonterminal{inner macro}\\
\nonterminal{inner macro}\is\terminal{(} \terminal{repeat}
         \terminal{(} \nonterminal{iterator}\any \terminal{)}
         \nonterminal{code}\oneplus \terminal{)}\\
\end{grammar}

Operations modify only their outputs and depends only on their inputs. The
name space of the opcodes is open-ended, the attributes are specific for each
opcode.

\begin{grammar}
\nonterminal{operation}\is\terminal{(} \terminal{op}
  \nonterminal{opcode} \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{output}\oneplus \terminal{)}
  \terminal{(} \nonterminal{input}\any \terminal{)} \terminal{)}\\
\nonterminal{opcode}\is\nonterminal{name}\\
\nonterminal{output}\is\nonterminal{name}\\
\nonterminal{input}\is\nonterminal{register}\\
    \also \nonterminal{constant expression}\\
\nonterminal{register}\is\terminal{(} \terminal{reg}
    \nonterminal{name} \terminal{)}
\end{grammar}

Memory operations read and write memory. The type of the data is provided
explicitly and is checked for writes (reads define the output which is checked
at use.)

\begin{grammar}
\nonterminal{memory access}\is
  \terminal{(} \terminal{load} \nonterminal{type name}
              \terminal{(} \nonterminal{attribute}\any \terminal{)}
          \nonterminal{output}
          \nonterminal{address} \terminal{)}\\
 \also
  \terminal{(} \terminal{store} \nonterminal{type name}
              \terminal{(} \nonterminal{attribute}\any \terminal{)}
          \nonterminal{address}
          \nonterminal{input} \terminal{)}\\
\nonterminal{address}\is\terminal{(} \nonterminal{input}\oneplus \terminal{)}\\
\end{grammar}

The next is the block. It packages codes together into a single code to
simplify syntax.

\begin{grammar}
\nonterminal{block}\is\terminal{(} \terminal{begin}
  \nonterminal{code}\oneplus \terminal{)}\\
\end{grammar}

The conditional is also simple. We provide two forms. The constant predicates
are handled in the compile time.
\begin{grammar}
\nonterminal{conditional}\is\terminal{(} \terminal{if-else}
  \nonterminal{predicate} \nonterminal{non-zero branch}
                          \nonterminal{zero branch} \terminal{)}\\
 \also \terminal{(} \terminal{if}
  \nonterminal{predicate} \nonterminal{non-zero branch} \terminal{)}\\
\nonterminal{predicate}\is\nonterminal{input}\\
\nonterminal{non-zero branch}\is\nonterminal{code}\\
\nonterminal{zero branch}\is\nonterminal{code}\\
\end{grammar}

The loop construct always runs through a given number of iterations. The
limits are computed once at the beginning of the loop. The loop variable is
of time int and is visible only inside the loop. Unrolling and prefetching
inside the loop is controlled by the attributes. The loop step is alway $1$.

\begin{grammar}
\nonterminal{loop}\is\terminal{(} \terminal{loop}
  \terminal{(} \nonterminal{attribute}\any \terminal{)}
  \terminal{(} \nonterminal{loop variable} \nonterminal{inclusive low}
              \nonterminal{exclusive high} \terminal{)}
  \nonterminal{code}\oneplus \terminal{)}\\
\nonterminal{loop variable}\is\nonterminal{output}\\
\nonterminal{inclusive low}\is\nonterminal{input}\\
\nonterminal{exclusive high}\is\nonterminal{input}\\
\end{grammar}

It is possible to use quare brackets [[[]]] instead if parentheses [[()]] in
any place as long as the closing backet matches the open one.
Also, [[;]] starts a commnet upto the end of line.

\section{TARGETS}
The following targets are supported:
\begin{itemize}
\item[\terminal{c-header}] The header file for C.
\item[\terminal{c99}] The programming language C as defined in ISO/IEC 9989.
\item[\terminal{xlc/bgl}] IBM's XLC compiler for BG/L with intrinsics.
\item[\terminal{bgl}] BG/L assembler.
\end{itemize}

\section{PROCEDURE ATTRIBUTES}
The following procedure attributes are understood:

\begin{grammar}
\terminal{(} \terminal{stem} \nonterminal{a-value}\oneplus\terminal{)}
\end{grammar}

All values of the [[stem]] are concatenated to produce the stem of the procedure
name. The result is affixed and suffixed appropriately to produce the procedure
name.

\begin{grammar}
\terminal{count-flops}
\end{grammar}

If present, the floating point operations in the procedure will be counted and
returned as an [[unsigned int]] result.


\begin{grammar}
\terminal{(} \terminal{return} \nonterminal{name}
    \nonterminal{type} \nonterminal{C type}\terminal{)}
\end{grammar}
Specifies that the procedure returns the final value of register
\nonterminal{name} and has \nonterminal{C type} as the return type. Value of
\nonterminal{type} is used to generate appropriate low level code and should
match \nonterminal{C type}.

\begin{grammar}
\terminal{(}\terminal{return} \nonterminal{output} \nonterminal{type name}
\nonterminal{C type}\terminal{)}
\end{grammar}

The final value of \nonterminal{output} will be returned from the procedure.
The procedure will have \nonterminal{C type} as its return type. The values of
\nonterminal{output} should be of type \nonterminal{type name}.

A procedure can not have both [[count-flops]] and [[return]] attributes.

\section{CONSTANT OPERATIONS}
\begin{grammar}
\terminal{(}\terminal{size-of} $T$\terminal{)}
\end{grammar}
Computes size of  type $T$.

\begin{grammar}
\terminal{(}\terminal{offset-of} $T$ $f$\terminal{)}
\end{grammar}
Computes offset of field $f$ in type $T$.

\begin{grammar}
\terminal{(}\terminal{+} $a$ $b$\any\terminal{)}
\end{grammar}
Computes $a+b\ldots$.
\begin{grammar}
\terminal{(}\terminal{-} $a$ $b$\any\terminal{)}
\end{grammar}
Computes $a-b\ldots$.
\begin{grammar}
\terminal{(}\terminal{*} $a$ $b$\any\terminal{)}
\end{grammar}
Computes $a*b\ldots$.
\begin{grammar}
\terminal{(}\terminal{=} $a$\oneplus\terminal{)}
\end{grammar}
If all arguments are equal, evaluates to $1$, otherwise to $0$.
\begin{grammar}
\terminal{(}\terminal{shift} $a$ $b$\terminal{)}
\end{grammar}
Computes $\left\lfloor2^ba\right\rfloor$.
\begin{grammar}
\terminal{(}\terminal{and} $a$\any\terminal{)}
\end{grammar}
Evaluates to $1$ is all arguments are non-zero, and to $0$ otherwise.
\begin{grammar}
\terminal{(}\terminal{or} $a$\any\terminal{)}
\end{grammar}
Evaluates to $1$ is any argument is non-zero, and to $0$ otherwise.
\begin{grammar}
\terminal{(}\terminal{not} $a$\terminal{)}
\end{grammar}
Evaluates to $1$ is $a=0$ and to $0$ otherwise.

\section{OPERATIONS}
In the following, non-terminal suffices denote implied types:
\begin{center}
\begin{tabular}{cl}
$i$ & integer \\
$f$ & single precision floating point \\
$d$ & double precision floating point \\
$c$ & double precision complex number \\
$p$ & pointer \\
$x$, $y$, $z$, $q$ & unspecifiend types used for reductions \\
$F$ & QCD fermion \\
$l$ & a lower half of QCD fermion \\
$h$ & an upper half of QCD fermion \\
$H$ & QCD projected fermion \\
$G$ & QCD gauge field
\end{tabular}
\end{center}

\subsection{QCD operations}
\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-fermion} \terminal{()} $r_F$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load QCD fermion from $M[a+b+\cdots]$ in current precision into register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-fermion-lo} \terminal{()} $r_l$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load the lower half of QCD fermion from $M[a+b+\cdots]$ in current precision
into register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-fermion-hi} \terminal{()} $r_h$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load the upper half of QCD fermion from $M[a+b+\cdots]$ in current precision
into register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-projected-fermion} \terminal{()}
 $r_H$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load QCD projected fermion from $M[a+b+\cdots]$ in current precision into
 register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{qcd-su-n} \terminal{()} $r_G$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load QCD gauge matrix from $M[a+b+\cdots]$ in current precision into
 register $r$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{qcd-fermion} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_F$ \terminal{)}
\end{grammar}

Store QCD fermion $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{qcd-projected-fermion} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_H$ \terminal{)}
\end{grammar}

Store QCD projected fermion $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{qcd-su-n} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_G$ \terminal{)}
\end{grammar}

Store QCD gauge matrix $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-mulf} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $u_G$ $a_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u a$ for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-mulf-conj} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $u_G$ $a_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u^\dagger a$ for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-mulh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $u_G$ $a_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u a$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-mulh-conj} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $u_G$ $a_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow u^\dagger a$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-scaleu} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $v_d$ $x_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a gauge matrix.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-scalef} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $v_d$ $x_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a fermion.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-scaleh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $v_d$ $x_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow v x$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-addu} \terminal{()}
   \terminal{(} $r_G$ \terminal{)}
   \terminal{(} $a_G$ $b_G$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$ for a gauge matrix.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-addf} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$ for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-addh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $a_H$ $b_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$ for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-maddf} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $s_d$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + s b$ for a fermion.
% XXXX --- make it so!

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-maddh} \terminal{()}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $a_H$ $s_d$ $b_H$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + s b$ for a projected fermion.
% XXXX --- make it so!

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-madd-lohi} \terminal{()}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $x_d$ $b_l$ $y_d$ $c_h$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + x b + y c$ for a fermion $a$, a lower half $b$ and
an upper half $c$.
% XXXX -- make it so!

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fnorm-init} \terminal{()}
   \terminal{(} $r_z$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Prepare to compute fermion norm. The type of $r$ is unspecified here.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fnorm-add} \terminal{()}
   \terminal{(} $r_z$ \terminal{)}
   \terminal{(} $a_z$ $b_F$ \terminal{)}
\terminal{)}
\end{grammar}
Add a fermion to the norm computation, $r\leftarrow a + b^\dagger b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fnorm-fini} \terminal{()}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_z$ \terminal{)}
\terminal{)}
\end{grammar}
Extract the final value of the norm from the norm computation.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fdot-init} \terminal{()}
   \terminal{(} $r_q$ \terminal{)}
   \terminal{(} \terminal{)}
\terminal{)}
\end{grammar}
Prepare to compute fermion dot product. The type of $r$ is unspecified here.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fdot-add} \terminal{()}
   \terminal{(} $r_q$ \terminal{)}
   \terminal{(} $a_q$ $b_F$ $c_F$ \terminal{)}
\terminal{)}
\end{grammar}
Add a fermion to the dot product computation, $r\leftarrow a + b^\dagger c$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fdot-fini} \terminal{()}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_q$ \terminal{)}
\terminal{)}
\end{grammar}
Extract the final value from the dot product computation.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-fermion-offset} \terminal{()}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $c_i$ $\alpha_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute an offset suitable for loading $\psi^c_\alpha$ with [[load complex]]
for a fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-projected-fermion-offset} \terminal{()}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $c_i$ $\alpha_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute an offset suitable for loading $\psi^c_\alpha$ with [[load complex]]
for a projected fermion.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-su-n-offset} \terminal{()}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute an offset suitable for loading $U^a_b$ with [[load complex]]
for a gauge matrix.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-project}
     \terminal{(} \terminal{[} \terminal{project} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_H$ \terminal{)}
   \terminal{(} $a_F$ \terminal{)}
\terminal{)}
\end{grammar}
Compute the projection of a fermion: if $s$ is [[plus]],
compute $r\leftarrow (1+\gamma_d)a$, if $s$ is [[minus]],
compute $r\leftarrow (1-\gamma_d)a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-unproject}
     \terminal{(} \terminal{[} \terminal{unproject} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_H$ \terminal{)}
\terminal{)}
\end{grammar}
Recover a fermion from projection: if $s$ is [[plus]], assume the projection was
$(1+\gamma_d)a$, if $s$ is [[minus]], assume the projection was
$(1-\gamma_d)a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{qcd-unproject-add}
     \terminal{(} \terminal{[} \terminal{unproject} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_F$ \terminal{)}
   \terminal{(} $a_F$ $b_H$ \terminal{)}
\terminal{)}
\end{grammar}
Recover a fermion from projection: if $s$ is [[plus]], assume the projection was
$(1+\gamma_d)b$, if $s$ is [[minus]], assume the projection was
$(1-\gamma_d)b$; add the result to $a$.

\subsection{Complex operations}
\begin{grammar}
\terminal{(} \terminal{load} \terminal{COMPLEX} \terminal{()} $r_c$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load default precision complex from $M[a+b+\cdots]$ into registero $r$.
 register $r$.

Specific size operations:
\begin{grammar}
\terminal{(} \terminal{load} \terminal{complex-float} \terminal{()} $r_c$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load single precision complex from $M[a+b+\cdots]$ into registero $r$.
 register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{complex-double} \terminal{()} $r_c$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load double precision complex from $M[a+b+\cdots]$ into registero $r$.
 register $r$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{COMPLEX} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_c$ \terminal{)}
\end{grammar}

Store default precision complex $r$ into $M[a+b+\cdots]$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{complex-float} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_c$ \terminal{)}
\end{grammar}

Store single precision complex $r$ into $M[a+b+\cdots]$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{complex-double} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_c$ \terminal{)}
\end{grammar}

Store double precision complex $r$ into $M[a+b+\cdots]$.

Double precision complex computations:
\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-add}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-sub}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-add-i}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + ib$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-sub-i}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - ib$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-times-plus-i}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow ia$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-times-minus-i}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow -ia$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-rmadd}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $\alpha_d$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + \alpha b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-cmadd}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ $c_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b c$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-rmul}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $\alpha_d$ $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow \alpha a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-cmul}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-cmul-conj}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a^{*} b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-neg}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow -a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-move}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-}
     \terminal{(} \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
   \terminal{(} $b_c$ $c_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a ? b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-}
     \terminal{(} \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
   \terminal{(} $b_c$ $c_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a ? b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-}
     \terminal{(} \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
   \terminal{(} $b_c$ $c_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a ? b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex}
     \terminal{(} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + i b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-real}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow \Re a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-imag}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_c$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow \Im a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-norm-init}
     \terminal{(} \terminal{[} \terminal{project} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_x$ \terminal{)}
\terminal{)}
\end{grammar}
Prepare to compute complex norm squared.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-norm-add}
     \terminal{(} \terminal{[} \terminal{project} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_x$ \terminal{)}
   \terminal{(} $a_x$ $b_c$ \terminal{)}
\terminal{)}
\end{grammar}
Add an element to the complex norm $r\leftarrow a + b^{*}b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-norm-fini}
     \terminal{(} \terminal{[} \terminal{project} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_x$ \terminal{)}
\terminal{)}
\end{grammar}
Extract the value for the norm $r\leftarrow a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-dot-init}
     \terminal{(} \terminal{[} \terminal{project} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_y$ \terminal{)}
\terminal{)}
\end{grammar}
Prepare to compute complex dot product squared.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-dot-add}
     \terminal{(} \terminal{[} \terminal{project} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_x$ \terminal{)}
   \terminal{(} $a_x$ $b_c$ $c_c$\terminal{)}
\terminal{)}
\end{grammar}
Add an element to the complex dot product $r\leftarrow a + b^{*}c$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{complex-dot-fini}
     \terminal{(} \terminal{[} \terminal{project} $d$ $s$
     \terminal{]} \terminal{)}
   \terminal{(} $r_c$ \terminal{)}
   \terminal{(} $a_x$ \terminal{)}
\terminal{)}
\end{grammar}
Extract the value for the dot product $r\leftarrow a$.

\subsection{Real operations}
\begin{grammar}
\terminal{(} \terminal{load} \terminal{REAL} \terminal{()} $r_d$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load default precision real from $M[a+b+\cdots]$ into register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{float} \terminal{()} $r_d$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load single precision real from $M[a+b+\cdots]$ into register $r$.

\begin{grammar}
\terminal{(} \terminal{load} \terminal{double} \terminal{()} $r_d$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load double precision real from $M[a+b+\cdots]$ into register $r$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{REAL} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_G$ \terminal{)}
\end{grammar}

Store default precision $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{float} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_G$ \terminal{)}
\end{grammar}

Store single precision $r$ into $M[a+b+\cdots]$ in current precision.


\begin{grammar}
\terminal{(} \terminal{store} \terminal{double} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_G$ \terminal{)}
\end{grammar}

Store double precision $r$ into $M[a+b+\cdots]$ in current precision.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-add}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-sub}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-mul}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a b$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-div}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a / b$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-madd}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ $b_d$ $c_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b c$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-move}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{double-neg}
     \terminal{(} \terminal{)}
   \terminal{(} $r_d$ \terminal{)}
   \terminal{(} $a_d$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow - a$.

\subsection{Integer operations}
\begin{grammar}
\terminal{(} \terminal{load} \terminal{int} \terminal{()} $r_G$
 \terminal{(} $a_i$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load integer from $M[a+b+\cdots]$ in register $r$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{int} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_i$ \terminal{)}
\end{grammar}

Store integer $r$ into $M[a+b+\cdots]$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-add}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-sub}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a - b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-mul}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-div}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a \idiv b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-mod}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a \imod b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-and}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a \iand b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-or}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a \ior b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-xor}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ $b_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a \ixor b$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-move}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{int-neg}
     \terminal{(} \terminal{)}
   \terminal{(} $r_i$ \terminal{)}
   \terminal{(} $a_i$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow - a$.

\subsection{Pointer operations}
\begin{grammar}
\terminal{(} \terminal{load} \terminal{pointer} \terminal{()} $r_p$
 \terminal{(} $a_p$ $b_i$\any\terminal{)}
\terminal{)}
\end{grammar}

Load pointer from $M[a+b+\cdots]$ into register $r$.

\begin{grammar}
\terminal{(} \terminal{store} \terminal{pointer} \terminal{()}
 \terminal{(} $a_p$ $b_i$\any\terminal{)} $r_p$ \terminal{)}
\end{grammar}

Store pointer $r$ into $M[a+b+\cdots]$.

\begin{grammar}
\terminal{(}\terminal{op} \terminal{pointer-add}
     \terminal{(} \terminal{)}
   \terminal{(} $r_p$ \terminal{)}
   \terminal{(} $a_p$ $b_i$\terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a + b$.


\begin{grammar}
\terminal{(}\terminal{op} \terminal{pointer-move}
     \terminal{(} \terminal{)}
   \terminal{(} $r_p$ \terminal{)}
   \terminal{(} $a_p$ \terminal{)}
\terminal{)}
\end{grammar}
Compute $r\leftarrow a$.



\end{document}
